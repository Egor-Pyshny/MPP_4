using FluentAssertions;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using TestGenerator.TestGenerators;
using static System.Net.Mime.MediaTypeNames;
using System.Reflection;

namespace Tests
{
    [TestClass]
    public class Tests
    {
        private string res = "";

        [TestInitialize]
        public void TestInitialize()
        {
            string basePath = AppDomain.CurrentDomain.BaseDirectory;
            basePath = Directory.GetParent(basePath).FullName;
            basePath = Directory.GetParent(basePath).FullName;
            basePath = Directory.GetParent(basePath).FullName;
            basePath = Directory.GetParent(basePath).FullName;
            string filePath = Path.Combine(basePath, "HelperClasses", "HelperClass.cs");
            Generator g = new Generator();
            var temp = g.GenerateTestClasses(File.ReadAllText(filePath));
            res = temp.Result.Values.ElementAt(0);
        }

        [TestMethod]
        public void TestVoidMethod()
        {
            string voidMethod = "[Test]\r\n        public void TestTest() {\r\n            int b = default(int);\r\n            Assert.DoesNotThrow(() => { _myClassUnderTest.Test(b); });\r\n            Assert.Fail(\"autogenerated\");\r\n        }";
            res.Should().Contain(voidMethod);
        }

        [TestMethod]
        public void TestCommonMethod()
        {
            string commonMethod = "[Test]\r\n        public void TestTest() {\r\n            a = new Mock<IDataReader>();\r\n            int b = default(int);\r\n            int c = default(int);\r\n            int actual = _myClassUnderTest.Test(a.Object, b, c);\r\n            int expected = default(int);\r\n            Assert.That(actual, Is.EqualTo(expected));\r\n            Assert.Fail(\"autogenerated\");\r\n        }";
            res.Should().Contain(commonMethod);
        }

        [TestMethod]
        public void TestSetUpMethod()
        {
            string setUpMethod = "[SetUp]\r\n        public void SetUp() {\r\n            _dependency1 = new Mock<IDataReader>();\r\n            _dependency2 = new Mock<ICloneable>();\r\n            string param1 = default(string);\r\n            _myClassUnderTest = new Class1(_dependency1.Object, _dependency2.Object, param1);\r\n        }";
            res.Should().Contain(setUpMethod);
        }

        [TestMethod]
        public void TestMethodsAmount()
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(res);
            var root = syntaxTree.GetRoot();
            var compilation = CSharpCompilation.Create("MyCompilation").AddSyntaxTrees(syntaxTree);
            var semanticModel = compilation.GetSemanticModel(syntaxTree);
            var methods = root.DescendantNodes().OfType<MethodDeclarationSyntax>();
            Type t = typeof(HelperClasses.Class1);
            var amount = t.GetMethods(BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly).Length;
            amount.Should().Be(methods.Count()-1);
        }
    }
}